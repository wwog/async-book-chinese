# 为什么使用异步？

我们都喜欢 Rust 赋予我们编写快速、安全软件的能力。
但是异步编程如何融入这一愿景呢？

异步编程，简称 async，是一种被越来越多的编程语言支持的 _并发编程模型_。
它允许你在少量操作系统线程上运行大量并发任务，同时通过 `async/await` 语法保留了普通同步编程的大部分外观和感觉。

## 异步 vs 其他并发模型

并发编程比常规的顺序编程不太成熟且不太 "标准化"。因此，我们表达并发的方式取决于语言支持哪种并发编程模型。
简要概述最流行的并发模型可以帮助你理解异步编程如何适应更广泛的并发编程领域：

- **操作系统线程** 不需要对编程模型进行任何更改，这使得表达并发非常容易。然而，线程之间的同步可能很困难，并且性能开销很大。
  线程池可以减轻其中一些成本，但不足以支持大规模 IO 密集型工作负载。
- **事件驱动编程**，结合 _回调_，可以非常高效，但往往会导致冗长、"非线性" 的控制流。
  数据流和错误传播通常很难跟踪。
- **协程**，像线程一样，不需要更改编程模型，这使得它们易于使用。像异步一样，它们也可以支持大量任务。然而，它们抽象掉了对于系统编程和自定义运行时实现者很重要的底层细节。
- **Actor 模型** 将所有并发计算划分为称为 actor 的单元，这些单元通过易错的消息传递进行通信，就像在分布式系统中一样。Actor 模型可以有效地实现，但它留下了许多实际问题未解决，例如流控制和重试逻辑。

总之，异步编程允许适合像 Rust 这样的低级语言的高性能实现，同时提供线程和协程的大部分人体工程学优势。

## Rust 中的异步 vs 其他语言

虽然许多语言都支持异步编程，但一些细节在实现上有所不同。Rust 的异步实现与大多数语言在几个方面有所不同：

- **Future 是惰性的**，在 Rust 中只有在被轮询时才会取得进展。丢弃一个 future 会阻止它取得进一步进展。
- **异步是零成本的**，在 Rust 中，这意味着你只为你使用的东西付费。
  具体来说，你可以使用异步而无需堆分配和动态分发，这对性能非常有利！
  这也允许你在受限环境中使用异步，例如嵌入式系统。
- **没有内置运行时**，Rust 不提供内置运行时。相反，运行时由社区维护的 crate 提供。
- **单线程和多线程** 运行时在 Rust 中都可用，它们有不同的优缺点。

## Rust 中的异步 vs 线程

在 Rust 中，异步的主要替代方案是使用操作系统线程，可以直接通过 [`std::thread`](https://doc.rust-lang.org/std/thread/) 使用，也可以间接通过线程池使用。
从线程迁移到异步或反之亦然通常需要大量的重构工作，无论是在实现方面还是（如果你正在构建库）任何公开的公共接口方面。因此，尽早选择适合你需求的模型可以节省大量的开发时间。

**操作系统线程** 适用于少量任务，因为线程带有 CPU 和内存开销。生成和切换线程非常昂贵，因为即使是空闲线程也会消耗系统资源。
线程池库可以帮助减轻其中一些成本，但不是全部。
然而，线程允许你重用现有的同步代码而无需进行重大的代码更改——不需要特定的编程模型。
在某些操作系统中，你还可以更改线程的优先级，这对于驱动程序和其他延迟敏感的应用程序很有用。

**异步** 提供了显著降低的 CPU 和内存开销，特别是对于具有大量 IO 密集型任务的工作负载，例如服务器和数据库。
在其他条件相同的情况下，你可以拥有比操作系统线程多几个数量级的任务，因为异步运行时使用少量（昂贵的）线程来处理大量（廉价的）任务。
然而，异步 Rust 会导致更大的二进制文件，因为异步函数会生成状态机，并且每个可执行文件都捆绑了一个异步运行时。

最后一点，异步编程并不比线程 _更好_，只是不同。
如果你不需要为了性能而使用异步，线程通常是更简单的选择。

### 示例：并发下载

在这个例子中，我们的目标是并发下载两个网页。
在典型的线程应用程序中，我们需要生成线程来实现并发：

```rust,ignore
{{#include ../../examples/01_02_why_async/src/lib.rs:get_two_sites}}
```

然而，下载网页是一个小任务；为如此少量的工作创建一个线程是非常浪费的。对于更大的应用程序，它很容易成为瓶颈。在异步 Rust 中，我们可以并发运行这些任务而无需额外的线程：

```rust,ignore
{{#include ../../examples/01_02_why_async/src/lib.rs:get_two_sites_async}}
```

在这里，没有创建额外的线程。此外，所有函数调用都是静态分发的，并且没有堆分配！
然而，我们需要首先将代码编写为异步的，本书将帮助你实现这一点。

## Rust 中的自定义并发模型

最后一点，Rust 不强迫你在线程和异步之间做出选择。
你可以在同一个应用程序中同时使用这两种模型，当你混合了线程和异步依赖项时，这很有用。
事实上，你甚至可以使用完全不同的并发模型，例如事件驱动编程，只要你能找到实现它的库。
