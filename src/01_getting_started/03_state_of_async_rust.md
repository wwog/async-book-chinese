# Rust 异步编程的现状

Rust 异步编程的部分内容享有与同步 Rust 相同的稳定性保证。其他部分仍在成熟中，并将随着时间的推移而改变。使用异步 Rust，你可以期待：

- 典型并发工作负载的出色运行时性能。
- 更频繁地与高级语言特性交互，例如生命周期和 Pinning。
- 一些兼容性约束，包括同步和异步代码之间，以及不同异步运行时之间。
- 更高的维护负担，因为异步运行时和语言支持正在不断演进。

简而言之，异步 Rust 比同步 Rust 更难使用，并且可能导致更高的维护负担，但作为回报，它为你提供了同类最佳的性能。
异步 Rust 的所有领域都在不断改进，因此这些问题的影响将随着时间的推移而减弱。

## 语言和库支持

虽然 Rust 本身支持异步编程，但大多数异步应用程序依赖于社区 crate 提供的功能。
因此，你需要依赖语言特性和库支持的混合体：

- 最基本的 trait、类型和函数，例如 [`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) trait，由标准库提供。
- `async/await` 语法由 Rust 编译器直接支持。
- 许多实用类型、宏和函数由 [`futures`](https://docs.rs/futures/) crate 提供。它们可以在任何异步 Rust 应用程序中使用。
- 异步代码的执行、IO 和任务生成由 "异步运行时" 提供，例如 Tokio 和 async-std。大多数异步应用程序和一些异步 crate 依赖于特定的运行时。有关更多详细信息，请参阅 ["异步生态系统"](../08_ecosystem/00_chapter.md) 部分。

你可能习惯于同步 Rust 中的某些语言特性，但在异步 Rust 中尚不可用。值得注意的是，在 1.75.0 稳定版之前，Rust 不允许你在 trait 中声明异步函数（并且对于这些 trait 的动态分发仍然有限制）。相反，你需要使用变通方法来实现相同的结果，这可能更加冗长。

## 编译和调试

在大多数情况下，异步 Rust 中的编译器和运行时错误的工作方式与它们在 Rust 中一直以来的工作方式相同。有一些值得注意的区别：

### 编译错误

异步 Rust 中的编译错误符合与同步 Rust 相同的高标准，但由于异步 Rust 通常依赖于更复杂的语言特性，例如生命周期和 Pinning，你可能会更频繁地遇到这些类型的错误。

### 运行时错误

每当编译器遇到异步函数时，它都会在后台生成一个状态机。异步 Rust 中的堆栈跟踪通常包含来自这些状态机的详细信息，以及来自运行时的函数调用。因此，解释堆栈跟踪可能比在同步 Rust 中稍微复杂一些。

### 新的故障模式

异步 Rust 中可能会出现一些新的故障模式，例如，如果你从异步上下文调用阻塞函数，或者如果你错误地实现了 `Future` trait。此类错误可以悄无声息地通过编译器，有时甚至通过单元测试。对底层概念有深刻的理解（本书旨在为你提供这些概念）可以帮助你避免这些陷阱。

## 兼容性注意事项

异步和同步代码并不总是可以自由组合。
例如，你不能直接从同步函数调用异步函数。
同步和异步代码也倾向于提倡不同的设计模式，这使得组合用于不同环境的代码变得困难。

即使是异步代码也不总是可以自由组合。一些 crate 依赖于特定的异步运行时才能运行。如果是这样，通常会在 crate 的依赖列表中指定。

这些兼容性问题可能会限制你的选择，因此请务必尽早研究你可能需要哪个异步运行时和哪些 crate。
一旦你选定了一个运行时，你就不必太担心兼容性问题了。

## 性能特征

异步 Rust 的性能取决于你使用的异步运行时的实现。
尽管支持异步 Rust 应用程序的运行时相对较新，但它们在大多数实际工作负载中表现出色。

也就是说，大多数异步生态系统都假设使用 _多线程_ 运行时。
这使得很难享受单线程异步应用程序的理论性能优势，即更廉价的同步。
另一个被忽视的用例是 _延迟敏感任务_，这对于驱动程序、GUI 应用程序等非常重要。此类任务依赖于运行时和/或操作系统支持才能得到适当的调度。
你可以期待将来对这些用例有更好的库支持。
