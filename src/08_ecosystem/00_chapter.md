# 异步生态系统
Rust 目前仅提供编写异步代码的最基本要素。
重要的是，执行器、任务、反应器、组合器以及低级 I/O future 和 trait 尚未在标准库中提供。在此期间，社区提供的异步生态系统填补了这些空白。

异步基础团队有兴趣扩展异步书中的示例，以涵盖多个运行时。
如果你有兴趣为这个项目做贡献，请在 [Zulip](https://rust-lang.zulipchat.com/#narrow/stream/201246-wg-async-foundations.2Fbook) 上联系我们。

## 异步运行时
异步运行时是用于执行异步应用程序的库。
运行时通常将 *反应器* 与一个或多个 *执行器* 捆绑在一起。
反应器为外部事件（如异步 I/O、进程间通信和计时器）提供订阅机制。
在异步运行时中，订阅者通常是表示低级 I/O 操作的 future。
执行器处理任务的调度和执行。
它们跟踪运行和挂起的任务，轮询 future 至完成，并在任务可以取得进展时唤醒任务。
"执行器" 一词经常与 "运行时" 互换使用。
在这里，我们使用 "生态系统" 一词来描述捆绑了兼容 trait 和功能的运行时。

## 社区提供的异步 Crate

### Futures Crate
[`futures` crate](https://docs.rs/futures/) 包含用于编写异步代码的有用 trait 和函数。
这包括 `Stream`、`Sink`、`AsyncRead` 和 `AsyncWrite` trait，以及组合器等实用程序。
这些实用程序和 trait 最终可能会成为标准库的一部分。

`futures` 有自己的执行器，但没有自己的反应器，因此它不支持执行异步 I/O 或计时器 future。
因此，它不被视为完整的运行时。
常见的选择是将 `futures` 中的实用程序与另一个 crate 中的执行器一起使用。

### 流行的异步运行时
标准库中没有异步运行时，也没有官方推荐的运行时。
以下 crate 提供了流行的运行时。
- [Tokio](https://docs.rs/tokio/): 一个流行的异步生态系统，具有 HTTP、gRPC 和跟踪框架。
- [async-std](https://docs.rs/async-std/): 一个提供标准库组件异步对应物的 crate。
- [smol](https://docs.rs/smol/): 一个小型、简化的异步运行时。
提供 `Async` trait，可用于包装 `UnixStream` 或 `TcpListener` 等结构体。
- [fuchsia-async](https://fuchsia.googlesource.com/fuchsia/+/master/src/lib/fuchsia-async/):
用于 Fuchsia 操作系统的执行器。

## 确定生态系统兼容性
并非所有异步应用程序、框架和库都彼此兼容，或者与每个操作系统或平台兼容。
大多数异步代码可以与任何生态系统一起使用，但某些框架和库需要使用特定的生态系统。
生态系统约束并不总是有文档记录，但有几条经验法则可以确定库、trait 或函数是否依赖于特定的生态系统。

任何与异步 I/O、计时器、进程间通信或任务交互的异步代码通常依赖于特定的异步执行器或反应器。
所有其他异步代码，如异步表达式、组合器、同步类型和流，通常与生态系统无关，前提是任何嵌套的 future 也与生态系统无关。
在开始项目之前，建议研究相关的异步框架和库，以确保与你选择的运行时以及彼此之间的兼容性。

值得注意的是，`Tokio` 使用 `mio` 反应器并定义了自己的异步 I/O trait 版本，包括 `AsyncRead` 和 `AsyncWrite`。
就其本身而言，它与 `async-std` 和 `smol` 不兼容，后者依赖于 [`async-executor` crate](https://docs.rs/async-executor)，以及 `futures` 中定义的 `AsyncRead` 和 `AsyncWrite` trait。

冲突的运行时要求有时可以通过兼容层来解决，兼容层允许你在一个运行时中调用为另一个运行时编写的代码。
例如，[`async_compat` crate](https://docs.rs/async_compat) 提供了 `Tokio` 和其他运行时之间的兼容层。

暴露异步 API 的库不应依赖于特定的执行器或反应器，除非它们需要生成任务或定义自己的异步 I/O 或计时器 future。
理想情况下，只有二进制文件才应负责调度和运行任务。

## 单线程 vs 多线程执行器
异步执行器可以是单线程的或多线程的。
例如，`async-executor` crate 既有单线程的 `LocalExecutor` 也有多线程的 `Executor`。

多线程执行器同时在多个任务上取得进展。
对于具有许多任务的工作负载，它可以大大加快执行速度，但在任务之间同步数据通常更昂贵。
建议在选择单线程和多线程运行时时测量应用程序的性能。

任务可以在创建它们的线程上运行，也可以在单独的线程上运行。
异步运行时通常提供将任务生成到单独线程的功能。
即使任务在单独的线程上执行，它们仍然应该是无阻塞的。
为了在多线程执行器上调度任务，它们还必须是 `Send`。
一些运行时提供生成非 `Send` 任务的函数，这确保每个任务都在生成它的线程上执行。
它们还可能提供将阻塞任务生成到专用线程的函数，这对于运行来自其他库的阻塞同步代码很有用。
