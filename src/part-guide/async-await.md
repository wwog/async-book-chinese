# Async 和 Await

在本章中，我们将开始进行一些 Rust 异步编程，并将介绍 `async` 和 `await` 关键字。

`async` 是函数（以及其他项目，如 traits，我们稍后会讲到）上的注解；`await` 是用于表达式中的运算符。但在我们深入探讨这些关键字之前，我们需要涵盖 Rust 异步编程的几个核心概念，这延续了上一章的讨论，在这里我们将把这些内容直接与 Rust 编程联系起来。

## Rust 异步概念

### 运行时

异步任务必须被管理和调度。通常任务的数量多于可用的核心数量，因此它们不能同时运行。当一个任务停止执行时，必须选择另一个任务来执行。如果一个任务正在等待 IO 或其他事件，它就不应该被调度，但当等待完成后，它应该被调度。这需要与操作系统交互并管理 IO 工作。

许多编程语言都提供运行时。通常，这个运行时不仅仅管理异步任务——它可能管理内存（包括垃圾回收），在异常处理中发挥作用，提供操作系统之上的抽象层，甚至是一个完整的虚拟机。Rust 是一门低级语言，致力于最小化运行时开销。因此，异步运行时的范围比许多其他语言的运行时要有限得多。设计和实现异步运行时的方法也有很多，所以 Rust 让你根据需求选择一个，而不是提供一个。这确实意味着开始异步编程需要额外的步骤。

除了运行和调度任务外，运行时还必须与操作系统交互以管理异步 IO。它还必须为任务提供定时器功能（这与 IO 管理相交）。关于运行时必须如何构建没有严格的规则，但一些术语和职责划分是常见的：

- *reactor* 或 *event loop* 或 *driver*（等效术语）：分发 IO 和定时器事件，与操作系统交互，并进行最低级别的执行驱动，
- *scheduler*：决定任务何时可以执行以及在哪个操作系统线程上执行，
- *executor* 或 *runtime*：结合了 reactor 和 scheduler，是用于运行异步任务的用户界面 API；*runtime* 也用于指代整个功能库（例如，Tokio crate 中的所有内容，而不仅仅是由 [`Runtime`](https://docs.rs/tokio/latest/tokio/runtime/struct.Runtime.html) 类型表示的 Tokio 执行器）。

除了上述执行器外，运行时 crate 通常还包括许多实用 traits 和函数。这些可能包括用于 IO 的 traits（例如 `AsyncRead`）和实现，用于常见 IO 任务（如网络或访问文件系统）的功能，锁，通道和其他同步原语，计时工具，与操作系统交互的工具（例如信号处理），用于处理 futures 和 streams（异步迭代器）的实用函数，或监控和观察工具。我们将在本指南中涵盖其中的许多内容。

有很多异步运行时可供选择。有些具有非常不同的调度策略，或者针对特定任务或领域进行了优化。在本指南的大部分内容中，我们将使用 [Tokio](https://tokio.rs/) 运行时。它是一个通用运行时，也是生态系统中最受欢迎的运行时。它是入门和生产工作的绝佳选择。在某些情况下，使用不同的运行时可能会获得更好的性能或能够编写更简单的代码。在本指南的后面，我们将讨论一些其他可用的运行时，以及为什么你可能会选择其中一个，甚至编写自己的运行时。

为了尽快启动并运行，你只需要一点样板代码。你需要在 Cargo.toml 中包含 Tokio crate 作为依赖项（就像任何其他 crate 一样）：

```
[dependencies]
tokio = { version = "1", features = ["full"] }
```

并且你将在 `main` 函数上使用 `tokio::main` 注解，以便它可以是一个异步函数（这在 Rust 中通常是不允许的）：

```rust,norun
#[tokio::main]
async fn main() { ... }
```

就是这样！你准备好编写一些异步代码了！

`#[tokio::main]` 注解初始化 Tokio 运行时并启动一个异步任务来运行 `main` 中的代码。在本指南的后面，我们将更详细地解释该注解的作用以及如何在没有它的情况下使用异步代码（这将给你更多的灵活性）。

### Futures-rs 和生态系统

TODO 背景和历史，futures-rs 的用途 - 曾经使用很多，现在可能不需要了，与 Tokio 和其他运行时重叠（有时有细微的语义差异），为什么你可能需要它（直接处理 futures，特别是编写自己的 futures，streams，一些工具）

其他生态系统内容 - Yosh 的 crates，替代运行时，实验性内容，其他？

### Futures 和任务

Rust 中异步并发的基本单位是 *future*。Future 只是一个普通的 Rust 对象（通常是结构体或枚举），它实现了 ['Future'](https://doc.rust-lang.org/std/future/trait.Future.html) trait。Future 代表延迟计算。也就是说，将在未来某个时刻准备好的计算。

我们将在本指南中大量讨论 futures，但最简单的入门方法是不必太担心它们。我们将在接下来的几节中经常提到它们，但直到后面我们才会真正定义它们或直接使用它们。Futures 的一个重要方面是它们可以组合成新的、“更大”的 futures（我们稍后将详细讨论*如何*组合它们）。

在上一章和这一章中，我非正式地使用了“异步任务”这个术语。我使用这个术语是指逻辑执行序列；类似于线程，但在程序内部管理，而不是由操作系统外部管理。从任务的角度思考通常很有用，但是，Rust 本身没有任务的概念，并且该术语用于表示不同的事物！这很令人困惑！更糟糕的是，运行时确实有任务的概念，并且不同的运行时对任务的概念略有不同。

从现在开始，我将尝试精确地使用关于任务的术语。当我只使用“任务”时，我是指可能与其他任务并发发生的计算序列的抽象概念。我将使用“异步任务”来表示完全相同的事情，但与作为操作系统线程实现的任务形成对比。我将使用“运行时的任务”来表示运行时想象的任何类型的任务，并使用“tokio 任务”（或其他特定运行时）来表示 Tokio 的任务概念。

Rust 中的异步任务只是一个 future（通常是由许多其他 future 组合而成的“大”future）。换句话说，任务是一个被执行的 future。但是，有时 future 会在不作为运行时任务的情况下被“执行”。这种 future 直观上是一个*任务*，但不是*运行时的任务*。当我们遇到它的例子时，我会更详细地说明这一点。


## 异步函数

`async` 关键字是函数声明的修饰符。例如，我们可以写 `pub async fn send_to_server(...)`。异步函数只是使用 `async` 关键字声明的函数，这意味着它是一个可以异步执行的函数，换句话说，调用者*可以选择不*等待函数完成再做其他事情。

用更机械的术语来说，当调用异步函数时，函数体不会像普通函数那样执行。相反，函数体及其参数被打包成一个 future，作为真实结果的替代返回。然后调用者可以决定如何处理该 future（如果调用者想要“立即”得到结果，那么它将 `await` 该 future，请参阅下一节）。

在异步函数内部，代码以通常的顺序方式执行[^preempt]，异步并没有什么不同。你可以从异步函数调用同步函数，执行照常进行。在异步函数中你可以做的一件额外的事情是使用 `await` 来等待其他异步函数（或 futures），这*可能*导致控制权的让出，以便另一个任务可以执行。

[^preempt]: 像任何其他线程一样，异步函数运行所在的线程可能会被操作系统抢占并暂停，以便另一个线程可以完成一些工作。但是，从函数的角度来看，如果不检查可能已被其他线程修改的数据（并且这些数据可能已被并行执行的另一个线程修改，而当前线程没有暂停），这是不可观察的。

## `await`

我们在上面说过，future 是将在未来某个时刻准备好的计算。为了获得该计算的结果，我们使用 `await` 关键字。如果结果立即准备好或无需等待即可计算，那么 `await` 只是进行该计算以产生结果。但是，如果结果尚未准备好，那么 `await` 将控制权移交给调度程序，以便另一个任务可以继续进行（这就是上一章提到的协作式多任务处理）。

使用 await 的语法是 `some_future.await`，即它是与 `.` 运算符一起使用的后缀关键字。这意味着它可以符合人体工程学地用于方法调用和字段访问链中。

考虑以下函数：

```rust,norun
// 一个异步函数，但它不需要等待任何东西。
async fn add(a: u32, b: u32) -> u32 {
  a + b
}

async fn wait_to_add(a: u32, b: u32) -> u32 {
  sleep(1000).await;
  a + b
}
```

如果我们调用 `add(15, 3).await`，那么它将立即返回结果 `18`。如果我们调用 `wait_to_add(15, 3).await`，我们最终会得到相同的答案，但在我们等待的同时，另一个任务将有机会运行。

在这个愚蠢的例子中，调用 `sleep` 是执行一些需要等待结果的长时间运行任务的替身。这通常是一个 IO 操作，结果是从外部源读取的数据或确认写入外部目标成功。读取看起来像 `let data = read(...).await?`。在这种情况下，`await` 将导致当前任务在读取发生时等待。一旦读取完成，任务将恢复（其他任务可以在读取任务等待时完成一些工作）。读取的结果可能是成功读取的数据或错误（由 `?` 处理）。

请注意，如果我们调用 `add` 或 `wait_to_add` 或 `read` 而不使用 `.await`，我们将不会得到任何答案！

什么？

调用异步函数返回一个 future，它不会立即执行函数中的代码。此外，future 在被 await 之前不会做任何工作[^poll]。这与其他一些语言形成对比，在这些语言中，异步函数返回一个立即开始执行的 future。

这是关于 Rust 异步编程的一个重要点。过了一会儿，这将成为第二天性，但它经常让初学者绊倒，特别是那些有其他语言异步编程经验的人。

关于 Rust 中 futures 的一个重要直觉是它们是惰性对象。为了完成任何工作，它们必须由外力（通常是异步运行时）驱动。

我们已经非常操作性地描述了 `await`（它运行一个 future，产生一个结果），但我们在上一章讨论了异步任务和并发，`await` 如何适应那个心智模型？首先，让我们考虑纯顺序代码：逻辑上，调用函数只是执行函数中的代码（带有一些变量赋值）。换句话说，当前任务继续执行由函数定义的下一个代码“块”。同样，在异步上下文中，调用非异步函数只是继续执行该函数。调用异步函数找到要运行的代码，但不运行它。`await` 是一个运算符，它继续执行当前任务，或者如果当前任务现在无法继续，则给另一个任务继续的机会。

`await` 只能在异步上下文中使用，目前这意味着在异步函数内部（稍后我们将看到更多类型的异步上下文）。要理解原因，请记住 `await` 可能会将控制权移交给运行时，以便另一个任务可以执行。在异步上下文中，只有一个运行时可以移交控制权。现在，你可以将运行时想象成一个只能在异步函数中访问的全局变量，稍后我们将解释它是如何真正工作的。

最后，关于 `await` 的另一个视角：我们之前提到 futures 可以组合在一起形成“更大”的 futures。`async` 函数是定义 future 的一种方式，而 `await` 是组合 futures 的一种方式。在 future 上使用 `await` 将该 future 组合到使用它的异步函数生成的 future 中。稍后我们将更详细地讨论这个视角以及组合 futures 的其他方法。

[^poll]: 或者被轮询 (polled)，这是一个比 `await` 更低级的操作，在使用 `await` 时在幕后发生。当我们详细讨论 futures 时，我们将讨论轮询。

## 一些 async/await 示例

让我们从重温我们的“hello, world!”示例开始：

```rust,edition2021
{{#include ../../examples/hello-world/src/main.rs}}
```

你现在应该认出了 `main` 周围的样板代码。它是为了初始化 Tokio 运行时并创建一个初始任务来运行异步 `main` 函数。

`say_hello` 是一个异步函数，当我们调用它时，我们必须在调用后加上 `.await` 才能将其作为当前任务的一部分运行。请注意，如果你删除 `.await`，那么运行程序什么也不做！调用 `say_hello` 返回一个 future，但它从未被执行，所以 `println` 从未被调用（至少编译器会警告你）。

这是一个稍微现实一点的例子，取自 [Tokio 教程](https://tokio.rs/tokio/tutorial/hello-tokio)。

```rust,norun
#[tokio::main]
async fn main() -> Result<()> {
    // 打开到 mini-redis 地址的连接。
    let mut client = client::connect("127.0.0.1:6379").await?;

    // 设置键 "hello" 的值为 "world"
    client.set("hello", "world".into()).await?;

    // 获取键 "hello"
    let result = client.get("hello").await?;

    println!("got value from the server; result={:?}", result);

    Ok(())
}
```

代码更有趣一点，但我们本质上是在做同样的事情——调用异步函数，然后等待执行结果。这次我们使用 `?` 进行错误处理——它的工作方式就像在同步 Rust 中一样。

尽管到目前为止我们一直在谈论并发、并行和异步，但这这两个例子都是 100% 顺序的。仅仅调用和等待异步函数不会引入任何并发，除非在等待任务等待时有其他任务要调度。为了向我们自己证明这一点，让我们看另一个简单（但人为）的例子：

```rust,edition2021
{{#include ../../examples/hello-world-sleep/src/main.rs}}
```

在打印 "hello" 和 "world" 之间，我们将当前任务休眠[^async-sleep]一秒钟。观察运行程序时会发生什么：它打印 "hello"，一秒钟什么也不做，然后打印 "world"。这是因为执行单个任务纯粹是顺序的。如果我们有一些并发，那么那一秒钟的小睡将是完成其他工作（如打印 "world"）的绝佳机会。我们将在下一节中看到如何做到这一点。

[^async-sleep]: 请注意，我们在这里使用的是异步休眠函数，如果我们使用 std 中的 [`sleep`](https://doc.rust-lang.org/std/thread/fn.sleep.html)，我们将使整个线程休眠。在这个玩具示例中这没有什么区别，但在实际程序中，这意味着在此期间其他任务无法在该线程上调度。这非常糟糕。


## 派生任务

我们已经讨论了 async 和 await 作为在异步任务中运行代码的一种方式。我们说过，`await` 可以让当前任务在等待 IO 或其他事件时休眠。当这种情况发生时，另一个任务可以运行，但是那些其他任务是如何产生的呢？就像我们使用 `std::thread::spawn` 来派生一个新任务一样，我们可以使用 [`tokio::spawn`](https://docs.rs/tokio/latest/tokio/task/fn.spawn.html) 来派生一个新的异步任务。请注意，`spawn` 是 Tokio（运行时）的一个函数，而不是来自 Rust 标准库，因为任务纯粹是一个运行时概念。

这是一个使用 `spawn` 在单独任务上运行异步函数的小例子：

```rust,edition2021
{{#include ../../examples/hello-world-spawn/src/main.rs}}
```

与上一个例子类似，我们有两个函数打印 "hello" 和 "world!"。但这次我们并发（并且并行）运行它们，而不是顺序运行。如果你运行程序几次，你应该会看到字符串以两种顺序打印——有时先打印 "hello"，有时先打印 "world!"。经典的并发竞争！

让我们深入了解这里发生了什么。这里涉及三个概念：futures、任务和线程。`spawn` 函数接受一个 future（记住它可以由许多较小的 futures 组成）并将其作为一个新的 Tokio 任务运行。任务是 Tokio 运行时调度和管理的概念（而不是单个 futures）。Tokio（在其默认配置中）是一个多线程运行时，这意味着当我们派生一个新任务时，该任务可能在与派生它的任务不同的操作系统线程上运行（它可能在同一个线程上运行，或者可能在一个线程上开始，稍后移动到另一个线程）。

因此，当一个 future 被派生为任务时，它与派生它的任务以及任何其他任务*并发*运行。如果它被调度在不同的线程上，它也可能与这些任务并行运行。

总而言之，当我们在 Rust 中编写两个紧随其后的语句时，它们是顺序执行的（无论是否在异步代码中）。当我们编写 `await` 时，这不会改变顺序语句的并发性。例如，`foo(); bar();` 是严格顺序的——调用 `foo`，然后调用 `bar`。无论 `foo` 和 `bar` 是否为异步函数，这都是真的。`foo().await; bar().await;` 也是严格顺序的，`foo` 被完全求值，然后 `bar` 被完全求值。在这两种情况下，另一个线程可能会与顺序执行交错，在第二种情况下，另一个异步任务可能会在 await 点交错，但在两种情况下，这两个语句*相对于彼此*都是顺序执行的。

如果我们使用 `thread::spawn` 或 `tokio::spawn`，我们会引入并发和潜在的并行，第一种情况是在线程之间，第二种情况是在任务之间。

在本指南的后面，我们将看到并发执行 futures 但从不并行执行的情况。


### 等待任务完成 (Joining tasks)

如果我们想获得执行派生任务的结果，那么派生任务可以等待它完成并使用结果，这称为*joining*任务（类似于 [joining](https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join) 线程，并且 joining 的 API 也是类似的）。

当任务被派生时，spawn 函数返回一个 [`JoinHandle`](https://docs.rs/tokio/latest/tokio/task/struct.JoinHandle.html)。如果你只是想让任务自己执行，可以丢弃 `JoinHandle`（丢弃 `JoinHandle` 不会影响派生的任务）。但是，如果你希望派生任务等待被派生的任务完成然后使用结果，你可以 `await` `JoinHandle` 来做到这一点。

例如，让我们再次重温我们的“Hello, world!”示例：


```rust,edition2021
{{#include ../../examples/hello-world-join/src/main.rs}}
```

代码与上次类似，但我们没有只调用 `spawn`，而是保存返回的 `JoinHandle`，稍后 `await` 它们。由于我们在退出 `main` 函数之前等待这些任务完成，因此我们不再需要 `main` 中的 `sleep`。

这两个派生的任务仍然并发执行。如果你运行程序几次，你应该会看到两种顺序。但是，`await` join handles 是对并发的限制：最后的感叹号 ('!') 将*总是*最后打印（你可以尝试相对于 `await` 移动 `println!("!");`。你可能还需要更改睡眠时间以获得可观察的效果）。

如果我们立即 `await` 第一个 `spawn` 的 `JoinHandle` 而不是保存它并稍后 `await`（即写成 `spawn(say_hello()).await;`），那么我们将派生另一个任务来运行 'hello' future，但派生任务会在做任何其他事情之前等待它完成。换句话说，没有可能的并发！你几乎从不想这样做（因为为什么要费心使用 spawn？直接写顺序代码就好了）。

### `JoinHandle`

我们将快速深入了解一下 `JoinHandle`。我们可以 `await` 一个 `JoinHandle` 这一事实表明 `JoinHandle` 本身就是一个 future。`spawn` 不是一个 `async` 函数，它是一个返回 future (`JoinHandle`) 的普通函数。它在返回 future 之前做一些工作（调度任务）（不像异步 future），这就是为什么我们不*需要* `await` `spawn`。等待 `JoinHandle` 会等待派生的任务完成，然后返回结果。在上面的例子中，没有结果，我们只是等待任务完成。`JoinHandle` 是一个泛型类型，它的类型参数是派生任务返回的类型。在上面的例子中，类型将是 `JoinHandle<()>`，产生 `String` 结果的 future 将产生类型为 `JoinHandle<String>` 的 `JoinHandle`。

`await` 一个 `JoinHandle` 返回一个 `Result`（这就是为什么我们在上面的例子中使用 `let _ = ...`，它避免了关于未使用 `Result` 的警告）。如果派生的任务成功完成，那么任务的结果将在 `Ok` 变体中。如果任务恐慌或被中止（[取消](../part-reference/cancellation.md)的一种形式），那么结果将是一个包含 [`JoinError` 文档](https://docs.rs/tokio/latest/tokio/task/struct.JoinError.html) 的 `Err`。如果你在项目中没有通过 `abort` 使用取消，那么 `unwrap` `JoinHandle.await` 的结果是一个合理的方法，因为这实际上是将恐慌从派生的任务传播到派生任务。
