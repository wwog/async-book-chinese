# IO 和阻塞问题

高效处理 IO（输入/输出）是异步编程的主要动力之一，大多数异步程序都执行大量 IO。从根本上说，IO 的问题在于它花费的时间比计算多几个数量级，因此仅仅等待 IO 完成而不是继续进行其他工作是非常低效的。理想情况下，异步编程允许程序在等待 IO 时继续进行其他工作。

本章是关于异步上下文中 IO 的介绍。我们将介绍阻塞和非阻塞 IO 之间的重要区别，以及为什么阻塞 IO 和异步编程不能混合使用（至少在没有经过一番思考和努力的情况下）。我们将介绍如何使用非阻塞 IO，然后看看 IO 和异步编程可能出现的一些问题。我们还将看看操作系统如何处理 IO，并先睹为快一些替代 IO 方法，如 io_uring。

最后，我们将介绍阻塞异步任务的其他一些方式（这很糟糕），以及如何正确地将异步编程与阻塞 IO 或长时间运行的 CPU 密集型代码混合使用。


## 阻塞和非阻塞 IO

IO 由操作系统实现；IO 的工作发生在单独的进程和/或专用硬件中，无论哪种情况都在程序的进程之外。IO 可以是同步的或异步的（分别称为阻塞和非阻塞）。同步 IO 意味着程序（或至少是线程）在 IO 进行时等待（又称阻塞），直到 IO 完成并从操作系统收到结果才开始处理。异步 IO 意味着程序可以在 IO 进行时继续取得进展，并稍后获取结果。这两种 IO 都有许多不同的操作系统 API，尽管异步领域的种类更多。

异步 IO 和异步编程并没有内在联系。然而，异步编程促进了符合人体工程学且高性能的异步 IO，这是异步编程的主要动力。由于同步 IO 导致的阻塞是异步编程性能问题的主要来源，我们必须小心避免它（下面将详细介绍）。

Rust 的标准库包含用于阻塞 IO 的函数和 traits。对于非阻塞 IO，你必须使用专门的库，这些库通常是异步运行时的一部分，例如 Tokio 的 [`io`](https://docs.rs/tokio/latest/tokio/io/index.html) 模块。

让我们快速看一个例子（改编自 Tokio 文档）：

```rust
use tokio::{io::AsyncWriteExt, net::TcpStream};

async fn write_hello() -> Result<(), Box<dyn std::error::Error>> {
    let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
    stream.write_all(b"hello world!").await?;

    Ok(())
}
```

`write_all` 是一个异步 IO 方法，它将数据写入 `stream`。这可能会立即完成，但更有可能需要一些时间才能完成，因此 `stream.write_all(...).await` 将导致当前任务在等待操作系统处理写入时暂停。调度程序将运行其他任务，当写入完成后，它将唤醒该任务并调度它继续工作。

但是，如果我们使用标准库中的写入函数，异步调度程序将不会参与，操作系统将在 IO 完成时暂停整个线程，这意味着不仅当前任务暂停，而且无法使用该线程执行其他任务。如果这种情况发生在运行时线程池中的所有线程上（在某些情况下可能只有一个线程），那么整个程序就会停止并且无法取得进展。这称为阻塞线程（或程序），对性能非常不利。在异步程序中永远不要阻塞线程很重要，因此你应该避免在异步任务中使用阻塞 IO。

阻塞线程可能是由长时间运行的任务或等待锁的任务引起的，也可能是由阻塞 IO 引起的。我们将在[本章末尾](#other-blocking-operations)对此进行更多讨论。

重复读取或写入是一种常见的模式，streams 和 sinks（又名异步迭代器）是这样做的一种便捷机制。它们在[专门的章节](streams.md)中介绍。


## 读取和写入

TODO

- 异步 Read 和 Write traits
  - 运行时的一部分
- 如何使用
- 具体实现
  - 网络 vs 磁盘
    - tcp, udp
    - 文件系统并不是真正的异步，而是 io_uring（参考那一章）
  - 实际例子
  - stdout 等
  - pipe, fd 等


## 内存管理

当我们读取数据时，我们需要将其放在某个地方，当我们写入数据时，它需要保存在某个地方直到写入完成。无论哪种情况，如何管理该内存都很重要。

TODO


- 缓冲区管理和异步 IO 的问题
- 不同的解决方案及其优缺点
  - 零拷贝方法
  - 共享缓冲区方法
- 帮助解决此问题的实用 crates，Bytes 等

## IO 高级主题

TODO


- 缓冲读/写
- Read + Write, split, join
- copy
- 单工和双工
- 取消
- 如果我们必须做同步 IO 怎么办？派生一个线程或使用 spawn_blocking（见下文）

## 操作系统的 IO 视图

TODO

- 不同类型的 IO 和机制，完成 IO，参考高级部分中的完成 IO 章节
  - 不同的运行时可以促进这一点
  - mio 用于低级接口


## 其他阻塞操作

正如本章开头所提到的，不阻塞线程对于异步程序的性能至关重要。不同类型的阻塞 IO 是一种常见的阻塞方式，但也可能通过进行大量计算或以异步调度程序不协调的方式等待来阻塞。

等待通常是由于使用非异步感知的同步机制引起的，例如，使用 `std::sync::Mutex` 而不是异步互斥锁，或等待非异步通道。我们将在[通道、锁定和同步](sync.md)一章中讨论这个问题。还有其他可能会以阻塞方式等待的方法，一般来说，你需要找到一种非阻塞或其他异步友好的机制，例如，使用异步 `sleep` 函数而不是标准库的函数。等待也可能是忙等待（实际上只是循环而不做任何工作，又名自旋锁），你应该尽量避免这种情况。

### CPU 密集型工作

进行长时间运行（即 CPU 密集型或 CPU 受限）的工作将阻止调度程序运行其他任务。这*是*一种阻塞，但它不像阻塞 IO 或等待那么糟糕，因为至少你的程序正在取得一些进展。然而（如果不加小心和考虑），这可能会在某种程度上（例如尾部延迟）导致性能欠佳，如果无法运行的任务需要在特定时间运行，甚至可能导致正确性问题。有一种说法是你根本不应该将异步 Rust（或像 Tokio 这样的通用异步运行时）用于 CPU 密集型工作，但这过于简单化了。正确的是，你不能在没有特殊处理的情况下混合 IO 和 CPU 受限（或更准确地说，长时间运行和延迟敏感）的任务，并期望一切顺利。

在本节的其余部分，我们将假设你混合了延迟敏感任务和长时间运行的 CPU 密集型任务。如果你没有任何延迟敏感的任务，那么情况会有所不同（通常更容易）。

运行长时间运行或阻塞任务基本上有三种解决方案：使用运行时的内置设施，使用单独的线程，或使用单独的运行时。

在 Tokio 中，你可以使用 [`spawn_blocking`](https://docs.rs/tokio/latest/tokio/task/fn.spawn_blocking.html) 来派生一个可能会阻塞的任务。这就像 `spawn` 派生任务一样工作，但在一个单独的线程池中运行任务，该线程池针对可能会阻塞的任务进行了优化（任务很可能会在自己的线程上运行）。请注意，这运行的是常规同步代码，而不是异步任务。这意味着任务无法取消（即使它的 `JoinHandle` 有一个 `abort` 方法）。其他运行时提供类似的功能。

你可以使用 [`std::thread::spawn`](https://doc.rust-lang.org/stable/std/thread/fn.spawn.html)（或类似函数）派生一个线程来执行阻塞工作。这非常简单。如果你需要运行大量任务，你可能需要某种线程池或工作调度程序。如果你不断派生线程并且线程数远多于可用核心数，你最终会牺牲吞吐量。[Rayon](https://github.com/rayon-rs/rayon) 是一个流行的选择，它可以轻松运行和管理并行任务。使用更特定于你的工作负载和/或对正在运行的任务有所了解的东西可能会获得更好的性能。

你可以为延迟敏感任务和长时间运行的任务使用单独的异步运行时实例。这适用于 CPU 受限的任务，但你仍然不应该使用阻塞 IO，即使在用于长时间运行任务的运行时上也是如此。对于 CPU 受限的任务，这是一个很好的解决方案，因为它是唯一支持长时间运行任务为异步任务的解决方案。它也很灵活（因为运行时可以配置为最适合它们正在运行的任务类型；实际上，有必要在运行时配置上投入一些精力以获得最佳性能），并让你受益于使用成熟、精心设计的子系统，如 Tokio。你甚至可以使用两个不同的异步运行时。无论如何，运行时必须在不同的线程上运行。

另一方面，你确实需要多做一些思考：你必须确保你在正确的运行时上运行任务（这可能比听起来更难），并且任务之间的通信可能很复杂。接下来我们将讨论同步和异步上下文之间的同步，但在多个异步运行时之间可能会更加棘手。每个运行时都是它自己的小任务宇宙，调度程序完全独立。Tokio 通道和锁*可以*从不同的运行时（甚至是非 Tokio 运行时）使用，但其他运行时的原语可能无法以这种方式工作。

由于每个运行时中的调度程序都不知道其他运行时（并且操作系统也不知道任何异步调度程序），因此没有协调或共享的调度优先级，并且工作无法在运行时之间窃取。因此，任务调度可能不是最优的（特别是如果运行时没有针对其工作负载进行良好调整）。此外，由于所有调度都是协作式的，长时间运行的任务仍然可能缺乏资源，延迟可能会受到影响。有关如何使长时间运行的任务更加协作，请参阅[下一节](#yielding)。

作为一个纯粹的调度程序，使用 Tokio 进行 CPU 工作可能会比专用的同步工作池具有略高的开销。考虑到支持异步编程所需的额外工作，这并不奇怪。对于大多数用户来说，这在实践中不太可能成为问题，但如果你的代码对性能极其敏感，则可能值得考虑。

对于上述任何解决方案，你都会有在不同上下文（同步和异步，或不同的异步运行时）中运行的任务。如果你需要在任务之间进行通信，那么你需要注意使用正确的同步和异步原语组合（通道、互斥锁等）以及这些原语上的正确（阻塞或非阻塞）方法。对于互斥锁和类似的锁，如果你需要跨 await 点持有锁或保护 IO 资源（它应该可以通过使用阻塞锁方法从同步上下文中使用），你应该使用异步版本，或者使用同步版本来保护数据或锁不需要跨 await 点持有的情况。Tokio 的异步通道可以通过阻塞方法从同步上下文中使用，但请参阅[这些文档](https://docs.rs/tokio/latest/tokio/sync/mpsc/index.html#communicating-between-sync-and-async-code)以了解有关何时使用同步或异步通道的一些详细信息。

那么，你应该使用上述哪种解决方案？

- 如果你在做阻塞 IO，你应该使用 `spawn_blocking`。你不能使用第二个运行时或其他线程池（至少如果你需要最佳性能）。
- 如果你有一个将永远运行的线程，你应该使用 `std::thread::spawn` 而不是使用任何类型的线程池（因为它会占用池中的一个线程）。
- 如果你在做*大量* CPU 工作，那么你应该使用线程池，无论是专门的还是第二个异步运行时。
- 如果你需要运行长时间运行的异步代码，那么你应该使用第二个运行时。
- 你可能会选择使用专用线程或 `spawn_blocking`，因为它很简单并且性能令人满意，即使更复杂的解决方案更优。


### 让出 (Yielding)

长时间运行的代码是一个问题，因为它没有给调度程序调度其他任务的机会。异步并发是协作式的：调度程序不能抢占任务来运行另一个任务。如果长时间运行的任务不向调度程序让出，那么调度程序无法停止它。但是，如果长时间运行的代码确实向调度程序让出，那么可以调度其他任务，并且任务长时间运行这一事实就不是问题了。这可以用作使用另一个线程进行 CPU 密集型工作或在其自己的运行时上进行 CPU 密集型工作的替代方案，以（可能）提高性能。

让出很容易，只需调用运行时的 yield 函数。在 Tokio 中是 [`yield_now`](https://docs.rs/tokio/latest/tokio/task/fn.yield_now.html)。请注意，这与标准库的 [`yield_now`](https://doc.rust-lang.org/stable/std/thread/fn.yield_now.html) 和用于从协程让出的 `yield` 关键字都不同。如果当前 future 在 `select` 或 `join` 内部运行（请参阅关于[并发组合 futures](concurrency-primitives.md) 的章节），调用 `yield_now` 不会向调度程序让出；这可能是也可能不是你想要发生的。

知道何时需要让出有点棘手。首先，你需要知道你的程序是否在隐式让出。这只能发生在 `.await` 处，所以如果你没有 `await`，那么你就没有让出。但是 await 不会自动向调度程序让出。只有当被 `await` 的叶 future 处于 pending（未就绪）状态或调用堆栈中的某处有显式 `yield` 时，才会发生这种情况。Tokio 和大多数异步运行时将在其 IO 和同步函数中执行此操作，但一般来说，如果不调试或检查源代码，你无法知道 `await` 是否会让出。

一个好的经验法则是，代码运行时间不应超过 10-100 微秒而不遇到潜在的让出点。

### 参考资料

- [Tokio 关于 CPU 受限任务和阻塞代码的文档](https://docs.rs/tokio/latest/tokio/index.html#cpu-bound-tasks-and-blocking-code)
- [博客文章：什么是阻塞？](https://ryhl.io/blog/async-what-is-blocking/)
- [博客文章：使用 Rustlang 的异步 Tokio 运行时处理 CPU 受限任务](https://thenewstack.io/using-rustlangs-async-tokio-runtime-for-cpu-bound-tasks/)
