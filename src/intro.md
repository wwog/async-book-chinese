注意：本指南目前正在重写，此前很长一段时间没有太多工作。它正在进行中，缺少很多内容，现有的内容也有点粗糙。

# 介绍

本书是 Rust 异步编程指南。旨在帮助你迈出第一步，并探索更多高级主题。我们不假设你有任何异步编程经验（无论是 Rust 还是其他语言），但我们假设你已经熟悉 Rust。如果你想学习 Rust，可以从 [Rust 程序设计语言](https://doc.rust-lang.org/stable/book/) 开始。

本书主要分为两部分：[第一部分](part-guide/intro.md) 是入门指南，旨在按顺序阅读，带你从完全的初学者进阶到中级水平。第二部分是关于更高级主题的独立章节集合。当你学完第一部分，或者如果你已经有一些 Rust 异步编程经验，这部分会很有用。

你可以通过多种方式浏览本书：

* 你可以按顺序从头到尾阅读。这是 Rust 异步编程新手的推荐路径，至少对于本书的 [第一部分](part-guide/intro.md) 来说是这样。
* 网页左侧有摘要目录。
* 如果你想了解某个广泛的主题，可以从主题索引开始。
* 如果你想查找关于特定主题的所有讨论，可以从详细索引开始。
* 你可以查看常见问题解答中是否回答了你的问题。


## 什么是异步编程，为什么要使用它？

在并发编程中，程序同时做多件事（或者至少看起来是这样）。使用线程编程是并发编程的一种形式。线程内的代码以顺序风格编写，操作系统并发执行线程。而在异步编程中，并发完全发生在你的程序内部（操作系统不参与）。异步运行时（在 Rust 中只是另一个 crate）管理异步任务，程序员通过使用 `await` 关键字显式让出控制权。

因为操作系统不参与，异步世界中的 *上下文切换* 非常快。此外，异步任务的内存开销比操作系统线程低得多。这使得异步编程非常适合需要处理大量并发任务且这些任务花费大量时间等待（例如，等待客户端响应或 IO）的系统。这也使得异步编程非常适合内存非常有限且没有提供线程的操作系统的微控制器。

异步编程还为程序员提供了对任务执行方式的细粒度控制（并行和并发级别、控制流、调度等）。这意味着异步编程在许多用途上既富有表现力又符合人体工程学。特别是，Rust 中的异步编程具有强大的取消概念，并支持多种不同风格的并发（使用包括 `spawn` 及其变体、`join`、`select`、`for_each_concurrent` 等构造来表达）。这些允许对超时、暂停和节流等概念进行可组合和可重用的实现。


## Hello, world!

为了让你体验一下 Rust 异步编程的样子，这里有一个 'hello, world' 示例。它没有并发，也没有真正利用异步的优势。它确实定义并使用了一个异步函数，并且确实打印了 "hello, world!"：

```rust,edition2021
{{#include ../examples/hello-world/src/main.rs}}
```

我们稍后会详细解释一切。现在，请注意我们如何使用 `async fn` 定义异步函数并使用 `.await` 调用它 - Rust 中的异步函数除非被 `await`，否则不会做任何事情[^blocking]。

像本书中的所有示例一样，如果你想查看完整的示例（例如包括 `Cargo.toml`）或自己在本地运行它，你可以在本书的 GitHub 仓库中找到它们：例如，[examples/hello-world](https://github.com/rust-lang/async-book/tree/master/examples/hello-world)。


## Rust 异步编程的发展

Rust 的异步特性已经开发了一段时间，但它还不是语言的 '完成' 部分。Rust 异步编程（至少是稳定版编译器和标准库中可用的部分）是可靠且高性能的。它被用于一些最大的科技公司中最苛刻的生产环境中。然而，还有一些缺失的部分和粗糙的边缘（粗糙是指人体工程学而不是可靠性）。在你的 Rust 异步编程之旅中，你可能会偶然发现其中的一些部分。对于大多数缺失的部分，都有变通方法，本书涵盖了这些方法。

目前，使用异步迭代器（也称为流）是大多数用户发现一些粗糙部分的地方。trait 中的一些异步用法尚未得到很好的支持。对于异步析构还没有好的解决方案。

Rust 异步编程正在积极开发中。如果你想关注开发进展，可以查看异步工作组的 [主页](https://rust-lang.github.io/wg-async/meetings.html)，其中包括他们的 [路线图](https://rust-lang.github.io/wg-async/vision/roadmap.html)。或者你可以阅读 Rust 项目中的异步 [项目目标](https://github.com/rust-lang/rust-project-goals/issues/105)。

Rust 是一个开源项目。如果你想为 Rust 异步编程的开发做出贡献，请从主 Rust 仓库中的 [贡献文档](https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md) 开始。


[^blocking]: 这实际上是一个糟糕的例子，因为 `println` 是 *阻塞 IO*，在异步函数中进行阻塞 IO 通常是一个坏主意。我们将在 [章节 TODO]() 中解释什么是阻塞 IO，并在 [章节 TODO]() 中解释为什么你不应该在异步函数中进行阻塞 IO。
