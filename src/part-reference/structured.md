# 结构化并发 (Structured Concurrency)

作者注 (TODO)：我们可能想在本书的更早部分讨论本章的一些内容，特别是作为设计原则（第一次介绍是在 guide/intro 中）。然而，为了更好地理解这个主题并写下一些东西，我从一个单独的章节开始。它仍然有点粗糙。

（注意：前几节讨论的是结构化并发的抽象概念，并不特定于 Rust 或异步编程（对比使用线程的同步并发编程）。我使用 'task' (任务) 来指代任何线程或异步任务或其他类似的并发原语）。

结构化并发是一种设计并发程序的哲学。要使程序完全遵守结构化并发的原则，需要某些语言特性和库，但即使没有这些特性，遵循该哲学也能获得许多好处。结构化并发独立于语言和并发原语（线程 vs 异步等）。许多人发现结构化并发的思想在使用异步 Rust 编程时非常有用。

结构化并发的核心思想是将任务组织成一棵树。子任务在其父任务之后开始，并且总是在父任务之前结束。这允许结果和错误总是传回给父任务，并要求父任务的取消总是传播给子任务。主要是，时间范围遵循词法范围，这意味着任务不应比创建它的函数或块活得更久。然而，只要长寿命任务在程序中以某种方式具体化（通常通过使用对象来表示父任务中子任务的时间范围），这就不是结构化并发的要求。

TODO 图表

结构化并发的命名类比于 [结构化编程](https://en.wikipedia.org/wiki/Structured_programming)，即控制流应该使用函数、循环等来结构化，而不是任意跳转 (`goto`)。

在我们考虑结构化并发之前，反思一下常见的并发设计在何种意义上是非结构化的是有帮助的。一个典型的模式是使用某种生成语句启动任务。然后该任务与系统中的其他任务（包括生成它的任务）并发运行直到完成。没有关于哪个任务先完成的约束。程序本质上只是一袋独立存在并可能随时终止的任务。任务的任何通信或同步都是临时的，程序员不能假设任何其他任务仍在运行。

非结构化并发的实际缺点是，从任务返回结果必须以超语言的方式发生，没有关于何时或如何发生的语言级保证。错误可能会被忽略，因为语言的错误处理机制不能应用于非结构化并发的不受约束的控制流。我们也无法保证任务的相对状态 - 任何任务都可能正在运行、成功终止或出错终止，或者被外部取消，独立于任何其他任务的状态[^join]。所有这些使得并发程序难以理解和维护。这种缺乏结构是并发编程被认为比顺序编程更难的一个原因。

值得注意的是，结构化并发是一种对程序施加限制的编程纪律。就像函数和循环比 goto 更不灵活一样，结构化并发比仅仅生成任务更不灵活。然而，正如结构化编程一样，结构化并发在灵活性方面的代价被可预测性的收益所抵消。

[^join]: 使用 join handles 在一定程度上缓解了这些缺点，但这是一个没有可靠保证的临时机制。要获得结构化并发的全部好处，你必须一丝不苟地总是使用它们，并正确处理取消和错误。没有语言或库的支持，这很难做到；我们将在下面讨论更多。

## 结构化并发的原则

结构化并发的关键思想是所有任务（或线程或其他什么）都被组织成一棵树。即，每个任务（除了作为根的主任务）都有一个父任务，并且没有父任务循环。子任务由其父任务启动[^start-parent]，并且必须 *总是* 在其父任务之前完成执行。兄弟任务之间没有约束。任务的父任务不能改变。

在推理实现结构化并发的程序时，关键的新事实是，如果一个任务是活跃的，那么它的所有祖先任务也必须是活跃的。这并不保证它们处于良好状态 - 它们可能正在关闭或处理错误的过程中，但它们必须以某种形式运行。这意味着对于任何任务（除了根任务），总是有一个活跃的任务来发送结果或错误。实际上，理想的方法是扩展语言的错误处理，以便错误总是传播到父任务。在 Rust 中，这应该适用于返回 `Result::Err` 和 panic。

此外，子任务的生命周期可以在父任务中表示。在常见情况下，任务的生命周期（其时间范围）与其启动的词法范围绑定。例如，在函数内启动的所有任务都应该在函数返回之前完成。这是一个极其强大的推理工具。当然，这对于所有情况来说都太严格了，因此任务的时间范围可以通过使用程序中的对象（通常称为 'scope' (范围) 或 'nursery' (托儿所)）扩展到词法范围之外。这样的对象可以被传递或存储，从而具有任意生命周期。我们仍然有一个重要的推理工具：绑定到该对象的任务不能比它活得更久（在 Rust 中，这个属性让我们将任务与生命周期系统集成）。

以上导致了结构化并发的另一个好处：它让我们能够跨多个任务推理资源管理。清理代码在资源不再使用时被调用（例如，关闭文件句柄）。在顺序代码中，何时调用清理代码的问题通过确保在对象超出范围时调用析构函数来解决。然而，在并发代码中，对象可能仍被另一个任务使用，因此何时清理尚不清楚（引用计数或垃圾收集是许多情况下的解决方案，但使推理对象的生命周期变得困难，这可能导致错误，并且还有运行时开销）。

父任务比其子任务活得更久的原则对取消有一个重要的含义：如果一个任务被取消，那么它的所有子任务都必须被取消，并且它们的取消必须在父任务的取消完成之前完成。这反过来又对如何在结构化并发系统中实现取消产生了影响。

如果任务由于错误而提前完成（在 Rust 中，这可能意味着 panic，以及提前返回），那么在返回之前，任务必须等待其所有子任务完成。实际上，提前返回必须触发子任务的取消。这类似于 Rust 中的 panic：panic 触发当前范围内的析构函数，然后向上遍历栈，在每个范围内调用析构函数，直到程序终止或 panic 被捕获。在结构化并发下，提前返回必须触发子任务的取消（从而清理这些任务中的对象），并向下遍历任务树取消所有（传递的）子任务。

有些设计在结构化并发下非常自然地工作（例如，具有单个工作要完成的工作任务），而其他设计则不太适合。通常这些模式是不绑定到特定任务是一个特性的模式，例如，工作池或后台线程。即使使用这些模式，任务通常也不应该比整个程序活得更久，所以总是有一个任务可以作为父任务。

[^start-parent]: 这实际上不是结构化并发的硬性要求。如果任务的时间范围可以在程序中表示并在任务之间传递，那么子任务可以由一个任务启动，但以另一个任务作为其父任务。

### 实现结构化并发

结构化并发的典范实现是 Python [Trio](https://trio.readthedocs.io/en/stable/) 库。Trio 是一个围绕结构化并发概念设计的用于异步编程和 IO 的通用库。Trio 程序使用 `async with` 结构来定义生成任务的词法范围。生成的任务与 [nursery](https://trio.readthedocs.io/en/stable/reference-core.html#nurseries-and-spawning) 对象相关联（这有点像 Rust 中的 [Scope](https://doc.rust-lang.org/stable/std/thread/struct.Scope.html)）。任务的生命周期与其 nursery 的动态时间范围绑定，在常见情况下，即 `async with` 块的词法范围。这强制执行了任务之间的父/子关系，从而强制执行了结构化并发的树不变量。

错误处理使用 Python 异常，这些异常会自动传播到父任务。

### 部分结构化并发

像许多编程技术一样，结构化并发的全部好处来自于 *只* 使用它。如果所有并发都是结构化的，那么推理整个程序的行为就会容易得多。然而，这对语言有不容易满足的要求；例如，在 Rust 中做非结构化并发很容易。然而，即使有选择地应用结构化并发的原则，或者从结构化并发的角度思考也是有用的。

你可以将结构化并发作为一种设计纪律。在设计程序时，总是考虑并记录任务之间的父子关系，并确保子任务在其父任务之前终止。这在正常执行下通常相当容易，但在面对取消和 panic 时可能会很困难。

结构化并发的另一个相当容易采用的元素是总是将错误传播到父任务。就像常规错误处理一样，最好的做法可能是忽略错误，但这应该在父任务的代码中显式进行。

从结构化并发中学到的另一个编程纪律是在取消父任务时取消所有子任务。这使得结构化并发保证更加可靠，并使取消通常更容易推理。

## 异步 Rust 的实用结构化并发

Rust 中的并发（无论是异步还是使用线程）本质上是非结构化的。任务可以任意生成，其他任务上的错误和 panic 可以被忽略，取消通常是瞬时的，并且不会传播到其他任务（见下文为什么这些问题不容易解决）。然而，有几种方法可以在你的程序中获得结构化并发的一些好处：

- 按照结构化并发在高层设计你的程序。
- 尽可能坚持结构化并发惯用语（并避免非结构化惯用语）。
- 使用 crates 使结构化并发更符合人体工程学且更可靠。

在 Rust 中使用结构化并发最棘手的问题之一是将取消传播到子 futures/任务。如果你使用 futures 并 [并发组合它们](../part-guide/concurrency-primitives.md)，那么这会自然发生，尽管很突然（丢弃 future 会丢弃它拥有的任何 futures，取消它们）。然而，当一个任务被丢弃时，没有机会向它生成的任务发送信号（至少使用 Tokio[^join_handle] 是这样）。

这意味着你只能假设比“真正的”结构化并发更弱的不变量：与其能够假设父任务总是活跃的，你只能假设父任务总是活跃的，除非它已被取消或已 panic。虽然这是次优的，但它仍然可以简化编程，因为你永远不必处理 *在正常执行下* 没有父任务来处理某些结果的情况。

TODO

- 所有权/生命周期自然导致 sc
- 推理资源

[^join_handle]: Tokio 的 `JoinHandle` 的语义是，如果 handle 被丢弃，那么底层任务被“释放”（对比丢弃），即子任务的结果不由任何其他任务处理。

### 将结构化并发应用于异步程序的设计

在设计程序方面，应用结构化并发有一些含义：

- 以树形结构组织程序的并发，即从父任务和子任务的角度思考。
- 时间范围应尽可能遵循词法范围，或者具体来说，函数不应返回（包括提前返回和 panic），直到函数中启动的任何任务完成。
- 数据通常从子任务流向父任务。当然，有些数据会从父任务流向子任务或以其他方式流动，但主要是，任务将其工作结果传递给父任务以进行进一步处理。这包括错误，所以父任务应该处理其子任务的错误。

如果你正在编写一个库并希望使用结构化并发（或者你希望该库在并发结构化程序中可用），那么库组件的封装包括时间封装是很重要的。即，它不启动在 API 函数返回后继续运行的任务。

由于 Rust 无法强制执行结构化并发规则，因此重要的是要意识到并记录程序（或组件）以何种方式结构化，以及它在哪里违反了结构化并发纪律。

一种有用的折衷模式是只允许在最高抽象级别进行非结构化并发，并且只针对从主任务的最外层函数生成的任务（理想情况下只从 `main` 函数生成，但程序通常有一些设置或配置代码，这意味着程序的逻辑“顶层”实际上有几层函数深）。在这种模式下，一堆任务从 `main` 生成，通常具有不同的职责并且彼此之间的交互有限。这些任务可能会重新启动，由任何其他任务启动新任务，或者具有与客户端或类似对象绑定的有限生命周期，即它们是并发非结构化的。在这些任务中的每一个内部，严格应用结构化并发。

TODO 为什么这有用？

TODO 在这里有一个案例研究会很棒。

### 结构化和非结构化惯用语

本小节涵盖了一些与结构化并发方法配合良好的惯用语，以及一些使结构化并发更加困难的惯用语。

遵循结构化并发的最简单方法是使用 futures 和 [并发组合](../part-guide/concurrency-primitives.md) 而不是任务和生成。如果你需要任务进行并行处理，那么你需要使用 `JoinHandle` 或 `JoinSet`。你必须注意，如果父任务 panic 或被取消，子任务可以正确清理。必须检查 Handles 是否有错误，以确保正确处理子任务中的错误。

解决缺乏取消传播的一种方法是避免突然取消（丢弃）任何可能有子任务的任务。相反，使用信号（例如，取消令牌），以便任务在终止之前可以取消其子任务。不幸的是，这与 `select` 不兼容。

要处理关闭程序（或组件），请使用显式关闭方法而不是丢弃组件，以便关闭函数可以等待子任务终止或取消它们（因为 `drop` 不能是异步的）。

一些惯用语与结构化并发配合得不好：

- 生成任务而不通过 join handle 等待其完成，或丢弃那些 join handles。
- Select 或 race 宏/函数。这些本质上不是结构化的，但由于它们突然取消 futures，它是非结构化取消的常见来源。
- 工作任务或池。对于异步任务，启动/关闭任务的开销非常低，以至于使用任务池而不是“数据”池（例如，连接池）可能几乎没有好处。
- 没有明确所有权结构的数据 - 这不一定与结构化并发相矛盾，但通常会导致设计问题。

### 结构化并发的 Crates

TODO

- crates: [moro](https://github.com/nikomatsakis/moro), [async-nursery](https://github.com/najamelan/async_nursery)
- futures-concurrency

## 相关主题

本节对于使用异步 Rust 进行结构化并发不是必须知道的，但对于好奇的人来说是有用的背景知识。

### 作用域线程 (Scoped threads)

Rust 线程的结构化并发工作得很好。虽然你无法阻止生成具有非作用域生命周期的线程，但这很容易避免。相反，限制自己使用作用域线程，请参阅 [`scope`](https://doc.rust-lang.org/stable/std/thread/fn.scope.html) 函数文档了解如何使用。使用作用域线程限制了子线程的生命周期，并自动将 panic 传播回父线程。不过父线程必须检查子线程的结果以处理错误。你甚至可以像 Trio nursery 一样传递 [`Scope`](https://doc.rust-lang.org/stable/std/thread/struct.Scope.html) 对象。取消通常不是 Rust 线程的问题，但如果你确实使用了线程取消，你必须手动将其与作用域线程集成。

Rust 特有的是，作用域线程允许子线程从父线程借用数据，这是并发非结构化线程无法做到的。这非常有用，并展示了结构化并发和 Rust 所有权风格的资源管理如何很好地协同工作。

### 异步 Drop 和作用域任务

在 Rust 中，析构函数 (`drop`) 用于确保在对象生命周期结束时清理资源。由于 futures 只是对象，它们的析构函数将是确保取消子 futures 的明显位置。然而，在异步程序中，清理操作通常希望是异步的（不这样做可能会阻塞其他任务）。不幸的是，Rust 目前不支持异步析构函数 (async drop)。支持它们的工作正在进行中，但由于许多原因这很困难，包括具有异步析构函数的对象可能会从非异步上下文中丢弃，并且由于调用 `drop` 是隐式的，因此没有地方编写显式的 `await`。

鉴于作用域线程是多么有用（无论是一般情况下还是对于结构化并发），另一个好问题是为什么没有类似的构造用于异步编程（'scoped tasks'）？TODO 回答这个问题

### 参考资料

如果你感兴趣，这里有一些很好的博客文章供进一步阅读：

- [Structured Concurrency](https://www.250bpm.com/p/structured-concurrency)
- [Tree-structured concurrency](https://blog.yoshuawuyts.com/tree-structured-concurrency/)
