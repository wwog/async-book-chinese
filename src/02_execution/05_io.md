# 执行器和系统 IO

在上一节 [Future Trait] 中，我们讨论了这个在套接字上执行异步读取的 future 示例：

```rust,ignore
{{#include ../../examples/02_02_future_trait/src/lib.rs:socket_read}}
```

这个 future 将读取套接字上的可用数据，如果没有数据可用，它将让出给执行器，请求在套接字再次变得可读时唤醒其任务。然而，从这个例子中并不清楚 `Socket` 类型是如何实现的，特别是 `set_readable_callback` 函数是如何工作的并不明显。我们如何安排在套接字变得可读时调用 `wake()`？一种选择是让一个线程不断检查 `socket` 是否可读，并在适当的时候调用 `wake()`。然而，这将非常低效，需要为每个阻塞的 IO future 提供一个单独的线程。这将大大降低我们异步代码的效率。

实际上，这个问题是通过与 IO 感知的系统阻塞原语集成来解决的，例如 Linux 上的 `epoll`、FreeBSD 和 Mac OS 上的 `kqueue`、Windows 上的 IOCP 以及 Fuchsia 上的 `port`（所有这些都通过跨平台 Rust crate [`mio`] 公开）。这些原语都允许线程阻塞在多个异步 IO 事件上，一旦其中一个事件完成就返回。实际上，这些 API 通常看起来像这样：

```rust,ignore
struct IoBlocker {
    /* ... */
}

struct Event {
    // 唯一标识发生并被监听的事件的 ID。
    id: usize,

    // 一组要等待的信号，或已发生的信号。
    signals: Signals,
}

impl IoBlocker {
    /// 创建一个新的异步 IO 事件集合以进行阻塞。
    fn new() -> Self { /* ... */ }

    /// 表达对特定 IO 事件的兴趣。
    fn add_io_event_interest(
        &self,

        /// 事件将发生在其上的对象
        io_object: &IoObject,

        /// 可能出现在 `io_object` 上的一组信号，
        /// 应该为其触发事件，与
        /// 赋予由此兴趣产生的事件的 ID 配对。
        event: Event,
    ) { /* ... */ }

    /// 阻塞直到其中一个事件发生。
    fn block(&self) -> Event { /* ... */ }
}

let mut io_blocker = IoBlocker::new();
io_blocker.add_io_event_interest(
    &socket_1,
    Event { id: 1, signals: READABLE },
);
io_blocker.add_io_event_interest(
    &socket_2,
    Event { id: 2, signals: READABLE | WRITABLE },
);
let event = io_blocker.block();

// 打印例如 "Socket 1 is now READABLE" 如果 socket 1 变得可读。
println!("Socket {:?} is now {:?}", event.id, event.signals);
```

Future 执行器可以使用这些原语来提供异步 IO 对象，例如套接字，这些对象可以配置回调以在特定 IO 事件发生时运行。在我们上面的 `SocketRead` 示例中，`Socket::set_readable_callback` 函数可能看起来像下面的伪代码：

```rust,ignore
impl Socket {
    fn set_readable_callback(&self, waker: Waker) {
        // `local_executor` 是对本地执行器的引用。
        // 这可以在创建套接字时提供，但在实践中
        // 许多执行器实现为了方便起见通过线程局部存储传递它。
        let local_executor = self.local_executor;

        // 此 IO 对象的唯一 ID。
        let id = self.id;

        // 将本地 waker 存储在执行器的映射中，以便在 IO 事件到达时调用它。
        local_executor.event_map.insert(id, waker);
        local_executor.add_io_event_interest(
            &self.socket_file_descriptor,
            Event { id, signals: READABLE },
        );
    }
}
```

我们现在可以只有一个执行器线程，它可以接收并将任何 IO 事件分发到适当的 `Waker`，这将唤醒相应的任务，允许执行器在返回检查更多 IO 事件之前驱动更多任务完成（循环继续...）。

[Future Trait]: ./02_future.md
[`mio`]: https://github.com/tokio-rs/mio
